# -*- coding: utf-8 -*-
"""Simple CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17gv0_szhUmSmN2xEXYITnliQUckA5ss9
"""

# INSTALLING TENSORFLOW
import tensorflow as tf

#WHAT IS THE TENSORFLOW'S VERSION

!pip freeze | grep tensorflow

# bring dataset
from tensorflow.keras.datasets import fashion_mnist

# by this we can convert a  vector class to binary class
from tensorflow.keras.utils import to_categorical

#A Sequential model is appropriate for a plain stack of layers where each layer has exactly one input tensor and one output tensor.
from tensorflow.keras.models import Sequential

#Dense layer is the regular deeply connected neural network layer. It is most common and frequently used layer.
from tensorflow.keras.layers import Dense

'''An optimizer is one of the two arguments required for compiling a Keras model:
Stochastic gradient descent (often abbreviated SGD) is an iterative method for optimizing an objective function with suitable smoothness properties'''
from tensorflow.keras.optimizers import SGD

#Matplotlib is a low level graph plotting library in python that serves as a visualization utility.
from matplotlib import pyplot as plt

#data loading
(X_train, y_train), (X_valid, y_valid) = fashion_mnist.load_data()

X_train.shape

y_train.shape

plt.figure(figsize=(5,5))
for k in range(12):
    plt.subplot(3, 4, k+1)
    plt.imshow(X_train[k], cmap='Greys')
    plt.axis('off')
plt.tight_layout()
plt.show()

X_valid.shape

_ = plt.imshow(X_valid[1], cmap='Greys')

X_train = X_train.reshape(60000, 784).astype('float32')
X_valid = X_valid.reshape(10000, 784).astype('float32')

X_train /= 255
X_valid /= 255

n_classes = 10
y_train = to_categorical(y_train, n_classes)
y_valid = to_categorical(y_valid, n_classes)

y_valid[0]

model = Sequential()
model.add(Dense(64, activation='sigmoid', input_shape=(784,)))
model.add(Dense(10, activation='softmax'))

model.summary()

model.compile(loss='mean_squared_error', optimizer=rl(lr=0.01), metrics=['accuracy'])

model.fit(X_train, y_train, batch_size=128, epochs=50, verbose=1, validation_data=(X_valid, y_valid))

model.evaluate(X_valid, y_valid)

valid_0 = X_valid[0].reshape(1, 784)

model.predict(valid_0)
